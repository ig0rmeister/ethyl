#!/usr/bin/env python3
# -*- coding: utf-8 -*-

__author__ = "Igor R"

import argparse, re, gzip, os, sys
from collections import OrderedDict
from datetime import datetime
from datetime import timedelta

def dir_path(path):
    if os.path.isdir(path):
        return path
    else:
        raise argparse.ArgumentTypeError('Readable_dir:{} is not a valid path'.format(path))

parser = argparse.ArgumentParser()
group = parser.add_mutually_exclusive_group()
group.add_argument('-p','--path', help= 'Full path to ethtool log files. Default: Current working directory', type=dir_path, default=os.getcwd())
group.add_argument('-f', '--file', help='Log file to parse. If not set, all ethtool logs in the current working directory will be checked', type=argparse.FileType('r'), nargs='?')
parser.add_argument('-c', '--counters', help='Comma separated list of counters to parse (e.g. rx_crc_errors). Default: rx_crc_errors,rx_pause_frames,tx_pause_frames', type=str,  default='rx_crc_errors,rx_pause_frames,tx_pause_frames')
parser.add_argument('-i', '--interfaces', help='Interface to parse (e.g. eth0). Default: eth0', type=str, default='eth0')
parser.add_argument('-s', '--start', help='Parsing start date (e.g. 2020-02-25 07:35 or 2020-02-25)', type=str)
parser.add_argument('-e', '--end', help='Parsing end date (e.g. 2020-02-25 07:45 or 2020-02-25)', type=str)
args = parser.parse_args()


if args.start is not None:
    try:
        startdate = datetime.strptime(args.start, '%Y-%m-%d %H:%M')
    except:
        startdate = datetime.strptime(args.start, '%Y-%m-%d')
else:
    startdate = ''

if args.end is not None:
    try:
        enddate = datetime.strptime(args.end, '%Y-%m-%d %H:%M')
    except:
        enddate = datetime.strptime(args.end, '%Y-%m-%d') + timedelta(hours=23,minutes=59)
else:
    enddate = ''


class LogEntry:
    def __init__(self, interface, counter, value):
        self.interface = interface
        self.counter = counter
        self.value = value

    def __eq__(self, other):
        if not isinstance(other, LogEntry):
            # don't attempt to compare against unrelated types
            return NotImplemented

        return self.interface == other.interface and self.counter == other.counter and self.value == other.value


#counters_list = [str(item) for item in args.counters.split(',')]
log_dict = {}
counters = args.counters
interfaces = args.interfaces


def printProgressBar (iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = 'â–“', printEnd = "\r"):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        decimals    - Optional  : positive number of decimals in percent complete (Int)
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
        printEnd    - Optional  : end character (e.g. "\r", "\r\n") (Str)
    """
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + '-' * (length - filledLength)
    print('\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix), end = printEnd)
    # Print New Line on Complete
    if iteration == total:
        print()


def populate_log_dict(log):
    for line_byte in log:
        try:
            line = str(line_byte, 'utf-8')
        except:
            line = line_byte
        if bool(re.search('\d\d\d\d-\d\d-\d\d \d\d:\d\d', line)):
            current_logdate = datetime.strptime(line.strip(), '%Y-%m-%d %H:%M')
            log_dict[current_logdate] = []
        match = re.search(r'^ethtool -S (.+):', line.strip())
        if match:
            current_interface = match.group(1)
        match = re.search(r'^({}): (\d+)'.format(counters.replace(',', '|')), line.strip())
        if match and current_interface in interfaces:
            log_dict[current_logdate].append(LogEntry(current_interface, match.group(1), match.group(2)))


def print_dates_and_arguments():
    print('\nStart date set: {}'.format(startdate.strftime('%Y-%m-%d %H:%M') if startdate != '' else 'None'))
    print('End date set {}'.format(enddate.strftime('%Y-%m-%d %H:%M') if enddate != '' else 'None'))
    print('Counters to parse: {}'.format(args.counters))
    print('Interface to parse: {}'.format(interfaces))
    print('\nOldest log entry found: ' + min(log_dict).strftime('%Y-%m-%d %H:%M'))
    print('Newest log entry found: ' + max(log_dict).strftime('%Y-%m-%d %H:%M'))



def filter_logdict():
    if (startdate == '') != (enddate == ''):
       if startdate == '':
           startdate = min(log_dict)
       if enddate == '':
           enddate = max(log_dict)

    for logentry in log_dict.copy():
        if (startdate != '' and  logentry < startdate) or \
           (enddate != '' and logentry > enddate) or \
           (startdate == '' and logentry != min(log_dict) and logentry != max(log_dict)) or \
           (enddate == '' and logentry != min(log_dict) and logentry != max(log_dict)):
               del log_dict[logentry]


def print_log_dict():
    prev_ethtool_entry_list = ''
    prev_ethtool_entry_interface = ''
    skipped_log_entries = 0
    for log_entry_date, ethtool_entry_list in sorted(log_dict.items(), key=lambda t: t[0]):
        if ethtool_entry_list == prev_ethtool_entry_list:
            if log_entry_date == max(log_dict):
                print('{}\n'.format('\n > Skipped: ' + str(skipped_log_entries) + ' repetetive entries\n' if skipped_log_entries != 0 else ''))
            skipped_log_entries += 1
        else:
            if (prev_ethtool_entry_list == ''):
                print('\n{}'.format(log_entry_date))
            elif (ethtool_entry_list != prev_ethtool_entry_list):
                print('{}\n{}'.format('\n > Skipped: ' + str(skipped_log_entries) + ' repetetive entries\n' if skipped_log_entries != 0 else '', log_entry_date))
                skipped_log_entries = 0
            for ethtool_entry in ethtool_entry_list:
                if (prev_ethtool_entry_interface == '') or (prev_ethtool_entry_interface != ethtool_entry.interface):
                    print('\n   {}'.format(ethtool_entry.interface))
                print('      {}: {}'.format(ethtool_entry.counter, ethtool_entry.value))
                prev_ethtool_entry_interface = ethtool_entry.interface
            prev_ethtool_entry_list = ethtool_entry_list


if not args.file:
    total = 0
    for file in os.listdir(args.path):
        if 'sf-ethtool-history' in file:
            total += 1
    count = 1
    if total != 0:
        os.chdir(args.path)
        print('\nImporting {} ethtool log files...'.format(total))
        printProgressBar(0, total)
        for file in os.listdir(args.path):
            if 'sf-ethtool-history' in file and 'gz' not in file:
                with open(file) as f:
                    log = f.readlines()
                    populate_log_dict(log)
                printProgressBar(count, total)
                count += 1

            if 'sf-ethtool-history' in file and 'gz' in file:
                with gzip.open(file) as f:
                    log = f.readlines()
                    populate_log_dict(log)
                printProgressBar(count, total)
                count += 1

        print_dates_and_arguments()
        print_log_dict()
    else:
        print('\nParsing error: ethtool-history log files not found in {}\n'.format(args.path))


if args.file and 'sf-ethtool-history' in args.file.name:
    file = os.path.realpath(args.file.name)

    if 'gz' not in file:
        with open(file) as f:
            log = f.readlines()
            populate_log_dict(log)

    if 'gz' in file:
        with gzip.open(file) as f:
            log = f.readlines()
            #create_logdict(log)

    #filter_logdict()
    print_dates_and_arguments()
    print_log_dict()
elif args.file and 'sf-ethtool-history' not in args.file.name:
    print('\nParsing error: Incorrect ethtool-history log file\n')
